import pytest
from unittest.mock import patch, MagicMock
from datetime import datetime
from typing import Any, Dict

from lambdas.common.game_schema import (
    create_game_schema,
    update_game_schema,
    generate_standardized_hash,
    generate_game_id,
)

#=================================================
# Fixtures & Helper Functions
#=================================================

@pytest.fixture
def mock_now():
    # Freeze time for consistent tests
    fixed_time = datetime(2022, 1, 1, 12, 0, 0)
    fixed_time_iso = fixed_time.isoformat()
    with patch("lambdas.common.game_schema.datetime") as mock_datetime:
        mock_datetime.now.return_value = fixed_time
        yield fixed_time_iso

@pytest.fixture
def mock_validations():
    with patch("lambdas.common.validation_utils.validate_board_size", return_value=True), \
         patch("lambdas.common.validation_utils.validate_language", return_value=True), \
         patch("lambdas.common.validation_utils.validate_board_matches_layout") as mock_validate_layout:
        # No return_value needed, it just shouldn't raise
        yield mock_validate_layout

@pytest.fixture
def mock_utils():
    # Mock the utility functions that generate words and solutions
    with patch("lambdas.common.game_schema.generate_valid_words", return_value=["WORD", "TEST"]), \
         patch("lambdas.common.game_schema.normalize_to_base", side_effect=lambda w: w.lower()), \
         patch("lambdas.common.game_schema.calculate_one_word_solutions", return_value=["ONE"]), \
         patch("lambdas.common.game_schema.calculate_two_word_solutions", return_value=[("TWO", "WORD")]), \
         patch("lambdas.common.game_schema.calculate_three_word_solutions", return_value=[("THREE", "WORD", "SOL")]), \
         patch("lambdas.common.game_schema.standardize_board", side_effect=lambda x: sorted(x)):
        yield

@pytest.fixture
def default_game_layout():
    return ["ABC", "DEF", "GHI", "XYZ"]

#=================================================
# Tests for create_game_schema
#=================================================

def test_create_game_schema_basic_success(mock_now, mock_validations, mock_utils, default_game_layout):
    # Minimal required fields
    result = create_game_schema(
        game_layout=default_game_layout,
        language="en",
        board_size="3x3",
        game_type="custom"  # not random, so no seed words required
    )
    assert result["gameId"] is not None
    assert result["gameLayout"] == default_game_layout
    assert result["validWords"] == ["WORD", "TEST"]
    assert result["oneWordSolutions"] == [] # 3x3 boards should not calculate one-word solutions
    assert result["twoWordSolutions"] == [("TWO", "WORD")]
    assert result["threeWordSolutions"] == [("THREE", "WORD", "SOL")]
    assert result["createdAt"] == mock_now
    assert result["language"] == "en"
    assert result["boardSize"] == "3x3"
    assert result["par"] == "N/A"
    assert result["totalRatings"] == 0
    assert result["clue"] == ""

def test_create_game_schema_random_game_without_seed_raises(mock_utils, default_game_layout):
    with pytest.raises(ValueError, match="Random games must be generated by seed words"):
        create_game_schema(
            game_layout=default_game_layout,
            language="en",
            board_size="3x3",
            game_type="random"
        )

def test_create_game_schema_invalid_board_size(mock_utils):
    # Mock validate_board_size to return False
    with patch("lambdas.common.validation_utils.validate_board_size", return_value=False):
        with pytest.raises(ValueError, match="Selected board size is not supported."):
            create_game_schema(
                game_layout=["A", "B", "C", "D"],
                language="en",
                board_size="1x1",
            )

def test_create_game_schema_invalid_language(mock_utils, default_game_layout):
    # Mock validate_language to return False
    with patch("lambdas.common.validation_utils.validate_language", return_value=False):
        with pytest.raises(ValueError, match="Selected language is not supported."):
            create_game_schema(
                game_layout=default_game_layout,
                language="xx",
                board_size="3x3",
            )


#=================================================
# Tests for update_game_schema
#=================================================

@pytest.fixture
def mock_game():
    """Fixture for a mock game object."""
    return {
        "gameId": "some-game-id",
        "language": "en",
        "boardSize": "3x3",
        "totalRatings": 5,
        "totalStars": 20,
        "clue": "Old clue"
    }

def test_update_game_schema_success(mock_game):
    """
    Test successful updates to a game schema.
    """
    # Arrange
    updates = {
        "clue": "New clue",
        "totalRatings": 10,
        "totalStars": 45
    }

    # Act
    updated_game = update_game_schema(mock_game, updates)

    # Assert
    assert updated_game["clue"] == "New clue"
    assert updated_game["totalRatings"] == 10
    assert updated_game["totalStars"] == 45

def test_update_game_schema_invalid_field(mock_game):
    """
    Test that invalid fields raise a ValueError.
    """
    updates = {"gameLayout": ["X", "Y", "Z"]}  # Not allowed

    with pytest.raises(ValueError, match="invalid fields"):
        update_game_schema(mock_game, updates)

def test_update_game_schema_no_game():
    """
    Test that missing the game object raises a ValueError.
    """
    updates = {"clue": "Doesn't matter"}

    with pytest.raises(ValueError, match="Game schema is required"):
        update_game_schema(None, updates)
        
def test_update_game_schema_missing_game_id(mock_game):
    """
    Test that a missing gameId raises a ValueError.
    """
    del mock_game["gameId"]  # Remove gameId from the mock game

    updates = {"clue": "New clue"}
    with pytest.raises(ValueError, match="gameId is required"):
        update_game_schema(mock_game, updates)

def test_update_game_schema_empty_updates(mock_game):
    """
    Test that an empty updates dictionary does not modify the game.
    """
    updates = {}

    updated_game = update_game_schema(mock_game, updates)

    # Assert that the game remains unchanged
    assert updated_game == mock_game


#=================================================
# Tests for Utility Functions
#=================================================

def test_generate_standardized_hash():
    test_layout = ["B", "A", "C"]
    result = generate_standardized_hash(test_layout)
    # Just check it's a SHA256 hash
    assert len(result) == 64
    assert isinstance(result, str)

def test_generate_game_id():
    game_id = generate_game_id()
    assert len(game_id) == 12
    # Check it's alphanumeric
    assert game_id.isalnum()

