from typing import Dict, Any, Optional, List, Tuple
import time
import uuid
import hashlib
from datetime import datetime, timezone
from lambdas.common.db_utils import fetch_game_by_id
from lambdas.common.game_utils import (
    standardize_board,
    calculate_one_word_solutions,
    calculate_two_word_solutions,
    calculate_three_word_solutions,
    generate_valid_words,
    standardize_board,
    normalize_to_base,
)
from lambdas.common.validation_utils import (
    validate_board_matches_layout,
    validate_board_size,
    validate_language,
)


def create_game_schema(
    game_id: Optional[str] = None,
    game_layout: Optional[List[str]] = None,
    game_type: str = "",
    official_game: Optional[bool] = None,
    standardized_hash: Optional[str] = None,
    valid_words: Optional[List[str]] = None,
    valid_word_count: Optional[int] = 0,
    base_valid_words: Optional[List[str]] = None,
    one_word_solutions: Optional[List[str]] = None,
    two_word_solutions: Optional[List[Tuple[str, str]]] = None,
    three_word_solutions: Optional[List[Tuple[str, str, str]]] = None,
    one_word_solution_count: Optional[int] = 0,
    two_word_solution_count: Optional[int] = 0,
    three_word_solution_count: Optional[int] = 0,
    nyt_solution: Optional[List[str]] = None,
    random_seed_word: Optional[str] = None,
    random_seed_words: Optional[List[str]] = None,
    dictionary: Optional[List[str]] = None,
    par: Optional[str] = None,
    board_size: str = "3x3",
    language: str = "en",
    total_ratings: Optional[int] = 0,
    total_stars: Optional[int] = 0,
    total_completions: Optional[int] = 0,
    total_words_used: Optional[int] = 0,
    total_letters_used: Optional[int] = 0,
    created_at: Optional[str] = None,
    created_by: str = "",
    clue: str = "",
) -> Dict[str, Any]:
    """
    Create a game schema with validation and default values.

    Args:
        game_id: Optional game ID. Generated if not provided.
        game_layout: List of letters forming the game layout.
        game_type: Type of the game ("nyt", "custom", "random").
        official_game: Whether the game is official (NYT).
        standardized_hash: Hash of the board layout.
        valid_words: Precomputed list of valid words. Generated if not provided.
        valid_word_count: Total count of valid words in the puzzle.
        base_valid_words: Precomputed list of valid words, with accents removed.
        one_word_solutions: Precomputed list of one-word solutions. Generated if not provided.
        two_word_solutions: Precomputed two-word solutions. Generated if not provided.
        three_word_solutions: Precomputed three-word solutions. Generated if not provided.
        two_word_solution_count: Total count of two-word solutions in the puzzle.
        three_word_solution_count: Total count of three-word solutions in the puzzle.
        nyt_solution: NYT-provided solution.
        random_seed_word: The one seed word used to generate a random game.
        random_seed_words: The two seed words used to generate a random game.
        dictionary: List of words used by NYT official games for validation.
        par: Expected minimum word count.
        board_size: Size of the board (e.g., "3x3").
        language: Language of the game (e.g., "en").
        total_ratings: The number of times a game has been rated.
        total_stars: The total number of stars a game has received in its ratings.
        total_completions: The number of times a game has been completed.
        total_words_used: The total number of words needed to complete this game.
        total_letters_used: The total length of all words used to complete this game.
        created_at: ISO timestamp for when the game was created.
        created_by: Identifier for the user who created the game, if applicable.
        clue: Clue for the two-word solution to this puzzle.

    Returns:
        A dictionary representing the game schema.
    """
    overall_start_time = time.time()
    print(f"[INFO] Starting create_game_schema function.")

    # Validate input fields
    if not validate_board_size(board_size):
        raise ValueError("Selected board size is not supported.")
    
    if not validate_language(language):
        raise ValueError("Selected language is not supported.")
    
    if not game_layout:
        raise ValueError("Game layout is required to create a game schema.")
    
    if game_type == "random":
        if not random_seed_word and not random_seed_words:
            raise ValueError("Random games must be generated by seed words (either one or two).")
        if random_seed_word and random_seed_words:
            raise ValueError("Specify either a single seed word or a pair of seed words, but not both.")
    
    # Validate board layout (raises an error if invalid)
    validate_board_matches_layout(game_layout, board_size)

    # Generate missing fields
    game_id = game_id or generate_game_id()
    if not standardized_hash:
        standardized_game_layout = standardize_board(game_layout)
        standardized_hash = generate_standardized_hash(game_layout)
    if valid_words is None or len(valid_words) == 0:
        print("[INFO] No valid words were passed to the two-word solution calculator. Generating...")
        valid_words = generate_valid_words(game_layout, language) or []
    base_valid_words = []
    for word in valid_words:
        base_word = normalize_to_base(word)
        base_valid_words.append(base_word)
    print(f"[INFO] {len(base_valid_words)} base words created from {len(valid_words)} valid words.")
    small_boards = ["2x2"]
    one_word_solutions = []
    if board_size in small_boards:
        one_word_solutions = (
            one_word_solutions
            or calculate_one_word_solutions(game_layout, valid_words, language)
            or []
        )
    two_word_solutions = (
        two_word_solutions 
        or calculate_two_word_solutions(game_layout, valid_words, language)
        or []
    )
    three_word_solutions = (
        three_word_solutions 
        or calculate_three_word_solutions(game_layout, language, valid_words=valid_words)
        or []
    )
    nyt_solution = nyt_solution or []
    random_seed_words = random_seed_words or []
    par = par or "N/A"
    total_ratings = total_ratings or 0
    total_stars = total_stars or 0
    official_game = official_game if official_game is not None else (game_type == "nyt")
    created_time = datetime.now().isoformat()

    overall_time = time.time() - overall_start_time
    print(f"[INFO] Entire game schema creation completed in {overall_time:.2f} seconds.")

    return {
        "gameId": game_id,
        "gameLayout": game_layout,
        "gameType": game_type,
        "officialGame": official_game,
        "standardizedHash": standardized_hash,
        "validWords": valid_words,
        "validWordCount": len(valid_words),
        "baseValidWords": base_valid_words,
        "oneWordSolutions": one_word_solutions,
        "twoWordSolutions": two_word_solutions,
        "threeWordSolutions": three_word_solutions,
        "oneWordSolutionCount": len(one_word_solutions),
        "twoWordSolutionCount": len(two_word_solutions),
        "threeWordSolutionCount": len(three_word_solutions),
        "nytSolution": nyt_solution,
        "randomSeedWord": random_seed_word,
        "randomSeedWords": random_seed_words,
        "dictionary": dictionary,
        "par": par,
        "boardSize": board_size,
        "language": language,
        "totalRatings": total_ratings,
        "totalStars": total_stars,
        "totalCompletions": total_completions,
        "totalWordsUsed": total_words_used,
        "totalLettersUsed": total_letters_used,
        "createdAt": created_time,
        "createdBy": created_by,
        "clue": clue,
    }


def update_game_schema(game_id: str, updates: dict) -> Dict[str, Any]:
    """
    Update specific attributes of a game in the DynamoDB table.

    Args:
        game_id (str): The ID of the game to update.
        updates (dict): A dictionary of attributes to update. Only certain fields are allowed.
    
    Raises:
        ValueError: If `game_id` is missing or updates contain disallowed fields.
        Exception: If the update fails (e.g., game_id does not exist).
    """
    # Allowed fields for updates
    allowed_fields = {
        "totalRatings",
        "totalStars",
        "totalCompletions",
        "totalWordsUsed",
        "totalLettersUsed",
        "clue",
    }

    invalid_fields = set(updates.keys()) - allowed_fields
    if invalid_fields:
        raise ValueError(f"The update contained invalid fields, or fields that are read-only.")

    if not game_id:
        raise ValueError("Game ID is required for updates.")

    existing_game = fetch_game_by_id(game_id)
    if not existing_game:
        raise ValueError("Game with specified ID does not exist.")

    # Update the fields in the game item
    updated_game = {**existing_game}
    for key, value in updates.items():
        updated_game[key] = value

    return updated_game


def generate_standardized_hash(standardized_game_layout: List[str]) -> str:
    """
    Generate a hash of the game layout, using a standardized letter layout so that 
    equivalent boards generate the same hash.
    
    Args:
        standardized_game_layout (List[str]): The input letters for this game, 
        sorted so that equivalent boards generate the same hash.
    """
    layout_str = "-".join(standardized_game_layout)
    return hashlib.sha256(layout_str.encode()).hexdigest()


def generate_game_id() -> str:
    """
    Generate a unique game id for a user-created game.

    Returns:
        str: A unique identifier string.
    """
    return str(uuid.uuid4())[-12:]